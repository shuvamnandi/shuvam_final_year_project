\chapter{Literature Review}
\label{ch3_lit_review}
In the area of coarse grain overlay architectures, the compute the routing logic can either perform the same operation over the time, or can loop over a short list of instructions or can execute a fully fledged instruction stream.
Based on this variety, researchers have proposed both spatially configured and time multiplexed  overlays that are mapped to the fine grained fabrics of modern FPGAs.
In spatially configured overlays, the compute logic and routing of the overlay are unchanged while a compute kernel is executing while in time multiplexed overlays, the compute logic and routing of the overlay change on a cycle by cycle basis while a compute kernel is executing~\cite{liu_soft_2013,brant_coarse_2013,paul_remorph:_2012}.
In this report, we focus on the work done by other researchers in the area of placement and routing on spatially configured overlays.


%\section{Spatially programmed FPGA Overlay Architectures}
%Spatially programmed overlays normally have a single instruction register within each \ac{FU} and hence FU behaves like a data flow processing element. 
%An array of such a data flow processing element, interconnected via a island style or \ac{NN} style programmable interconnect, can be considered as a Spatially programmed overlay architecture.
%This type of overlay fits well in a scenario where performance in terms of throughput is a primary objective given the rich logic resources.
%With the exponential increase of logic density on FPGA devices, it is now possible to accommodate a massive number of FUs on an FPGA which allows to map all of the operations in a compute kernel spatially on the array of FUs to exploit the parallelism available. The throughput under this mapping would be one kernel iteration per cycle since the initiation interval would be one.
%The primary target in such a scenario would no longer be hardware sharing given the limited area constraint, but rather achieving the highest performance in terms of throughput under the rich logic resources.
%The key feature of such an array is the ability to exploit large amount of physical hardware resources to deliver scalable performance for data-parallel and throughput oriented applications.
%Statically programmed overlays support distributed dataflow execution and enable fine grained pipelining and massive parallelism of FPGAs to be exploited.

%\section{Intermediate Fabrics}
An island-style interconnect based overlay architecture (spatially configured), referred to as an intermediate fabric (IF)~\cite{coole_intermediate_2010},~\cite{stitt_intermediate_2011} was proposed to support near-instantaneous placement and routing (shown in Fig.~\ref{if}).
Standard VPR~\cite{betz1997vpr} algorithms were used for placement and routing of compute kernels.
It consists of 192 heterogeneous functional units comprising 64 multipliers, 64 subtracters, 63 adders, one square root unit, and five delay elements with a 16-bit datapath and supported the fully parallel, pipelined implementation of compute kernels. 


\begin{figure}[!h]
	\centering
	%\includegraphics[width=14cm]{figures/if_overlay.png}
	\caption{Intermediate Fabrics as Island-style Overlay~\cite{coole_intermediate_2010}.}
	\label{if}
\end{figure}

Unlike a physical device, whose architecture must support many applications, IFs have been specialized for particular domains or even individual applications. Such specialization hides the complexity of fine-grained \ac{COTS} devices, thus enabling fast place and route (700x speedup over vendor tools) at the cost of significant area (34\% - 44\%) and performance (7\%) overhead when implemented on an Altera Stratix III FPGA~\cite{stitt_intermediate_2011}. 
However, the IF only achieved an $F_{\mathit{max}}$ of 125\,MHz resulting in low throughput for the application benchmarks tested.
Area overhead comes into picture mainly because of virtual interconnect logic which comprised of multiplexers based routing. 
Based on the above mentioned work on IFs, an end-to-end tool flow was presented for FPGA-accelerated scientific computing \cite{stitt_end--end_2011}.

%\section{Mesh of FU based Overlay}
Another spatially configured overlay based on nearest neighbor interconnect (shown in Fig.~\ref{meshfu}) was proposed in~\cite{capalija_high-performance_2013}.
This overlay executes a given DFG by mapping the graph nodes to the FUs and by configuring the routing logic to establish inter-FU connections that reflect the graph edges~\cite{capalija_high-performance_2013}. 
Multiple instances of the DFGs are then executed in a pipelined fashion on the overlay to achieve high performance.    
%In addition to integer arithmetic, overlay also used floating point processing elements.
It consisted of a 24$\times$16 overlay with a nearest-neighbor-connected mesh of 214 routing cells and 170 heterogeneous functional units (FU) comprising 51 multipliers, 103 adders and 16 shift units.
When implemented on an Altera Stratix IV FPGA, the overlay consumed 75\% of the total device ALMs, with the routing network consuming 90\% of the ALM resource used.
An $F_{\mathit{max}}$ of 355\,MHz and a peak throughput of 60 GOPS was reported.
A placer and router was developed by customizing VPlace~\cite{marquardt2000timing} and PathFinder~\cite{mcmurchie1995pathfinder}, respectively.


\begin{figure}[!h]
	\centering
	%\includegraphics[width=12cm]{figures/hp_overlay.png}
	\caption{Nearest-neighbor connected Mesh of Functional units~\cite{capalija_high-performance_2013}.}
	\label{meshfu}
\end{figure}

%Key features are high speed of overlay, Mesh of FUs, elastic pipelines for latency balancing and synchronization, runtime compilation, data driven pipeline units, dynamic and distributed control, No Fmax drop on scaling the overlay size, DFG relocation within VDR, data-driven execution (dynamic triggering of FU on the availability of input data).


%\section{DySER Architecture}

DySER~\cite{govindaraju2012dyser, govindaraju2011dynamically} was proposed as a coarse grained overlay architecture for improving the performance of general purpose processors.
It was originally designed as a heterogeneous array of 64 functional units interconnected with a circuit-switched mesh network and implemented on ASIC.
The DySER architecture was then improved and prototyped, along with the OpenSPARC T1 RTL, on a Xilinx XC5VLX110T FPGA~\cite{benson2012design}.
However, due to excessive LUT consumption, it was only possible to fit a 2x2 32-bit DySER, a 4x4 8-bit DySER or an 8x8 2-bit DySER on the FPGA.
An adapted version of a 6x6 16-bit DySER was implemented on a Xilinx Zynq-7020~\cite{heart2015-jain}. The larger DySER array was achieved by using a DSP block as the compute logic, thus better targeting the architecture to the FPGA.


%\section{DSP Block based Overlay Architecture}
An overlay architecture with the FU based on the DSP blocks found in Xilinx FPGAs was recently proposed~\cite{fccm2015-jain}.
This overlay combines multiple operations in a compute kernel and maps them to the DSP block, resulting in a significant reduction in the number of processing nodes required. 
An $F_{\mathit{max}}$ of 370 MHz with throughputs better than that achieved by directly implementing the benchmarks onto the fabric using Xilinx Vivado HLS were reported.
In the next chapters, we use this overlay architecture as a base platform to discuss about the placement and routing of data flow graphs.
%
